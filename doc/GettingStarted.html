<html> <head>
    <title>Getting Started with LSST Development</title>
    <style type="text/css">
      body     {font-family: Arial, Helvetica, sans-serif;}
      code     {font-weight: bold; }
      p.code   {background-color: #eeeeee; font-family: monospace;
                white-space: pre; border-color: #880000;
                border-width: thin; border-style: solid; 
                padding-left: 1em; padding-top: 1ex; padding-bottom: 1ex; }
      .note    {background-color: #eeeeee; font-size: 10pt;
                border-color: black; border-width: thin; border-style: solid; 
                padding-left: 1em; padding-top: 1ex; padding-bottom: 1ex; }
    </style>
</head>

<body>
<h1>Getting Started with LSST Development <br>
<font size="+0">Ray Plante, NCSA</font><br>
<font font-weight="400" size="-1">
<!-- hhmts start -->
Last modified: Wed Sep 24 10:03:58 2008
<!-- hhmts end --></font></h1>

<p>
Whether you are a developer, a tester, a system maintainers, or just
curious about the LSST code, you will eventually find yourself in need
of installing all or part of the LSST Software Stack.  This section
describes how to install the software stack and development
environment.  It is mainly intended for the LSST developer; however,
this document will be helpful to administrators that just wish to
install a stable release.
</p>

<p>
Further detailed information on the build system can be found in the
document the "LSST Build and Test Systems".
</p>

<h3>Contents</h3>

<dl>
  <dt> <a href="#overview">1. Overview</a> </dt>
  <dt> <a href="#lsst_home">2. Building your LSST_HOME: the Standard LSST Software Stack</a>
  <dd> <dl>
         <dt> <a href="#lh_recipe">2.1.  Step-by-step Instructions</a> </dt>
         <dt> <a href="#lh_results">2.2.  What You've Created</a>      </dt>
         <dt> <a href="#lh_install">2.3.  Installing Additional Packages</a></dt>
         <dt> <a href="#lh_prob">2.4.  If Something Goes Wrong</a>  </dt>
       </dl> </dd>
  <dt> <a href="#sandbox">3.  Creating a Development Sandbox</a>       </dt>
  <dt> <a href="#rcfile">4.  Updating Your Shell RC File</a>           </dt>
  <dt> <a href="#testdata">5.  Downloading test data</a>               </dt>
  <dt> <a href="#srcco">6.  Checking out LSST source code</a>          </dt>
  <dd> <dl>
         <dt> <a href="#svnlsst">6.1. Using Subversion for LSST
              Development</a>                                          </dt> 
         <dt> <a href="#svnsurvival">6.2. An SVN Survival Guide</a>    </dt> 
       </dl> </dd>
  <dt> <a href="#work">7.  Working with LSST packages</a>              </dt>
  <dd> <dl>
         <dt> <a href="#eups">7.1. An Introduction to EUPS</a>         </dt>
         <dt> <a href="#build">7.2. Building and Installing an LSST
              Package</a>                                              </dt> 
         <dt> <a href="#newpkg">7.3. Creating a New LSST Package</a>   </dt>
         <dt> <a href="#release">7.4. Creating a Package Release</a>   </dt>
       </dl> </dd>
  <dt> <a href="#resources">8.  Additional Resources</a> </dt>
  <dd> <dl>
         <dt> <a href="#trac">8.1  Issue Tracking with Trac</a> </dt>
         <dt> <a href="#continuum">8.2  Build Testing with
              Continuum</a> </dt>
       </dl> </dd>
</dl>

<a name="overview">
<h2>1. Overview</h2></a>

<p>
In general, the development environment is made up of three areas.
The first is a complete installation of the standard software stack,
which we refer to as <code>LSST_HOME</code>.  This
includes both third-party packages and packages developed by the LSST
team.  This stack may contain multiple versions of the various
packages, and our tools allow you to switch between them as necessary.
The second area is the developer's sandbox or
<code>LSST_DEVEL</code>.  This is where you install
and test your own private versions of LSST software.  This area looks
just like the LSST_HOME area, except that it normally will only
include versions of software that you are actually developing.  The
third area is your copy of the software source tree, checked out of
the code repository.
</p>

<p>
In brief, to create a complete LSST development environment, you will..
</p>

<ol>
  <li> Use the LSST distribution tools to download and install the
        software stack (<a href="#lsst_home">Section 2</a>), </li>
  <li> Create a software installation sandbox
       (<a href="#sandbox">Section 3</a>), </li>
  <li> Use the tools to download selected test data
       (<a href="#testdata">Section 5</a>), and </li>
  <li> Check out source code from the code repository
       (<a href="#srcco">Section 6</a>) </li>
</ol>

<p>
Once you have an <code>LSST_HOME</code> area
installed (or have one that was installed by someone else made
available to you), you will probably find it convenient to
add some lines to your shell "rc" file (Section 4).  You will also
need to become familiar with the developers' build process; an
introduction to this covered in section 7.
</p>

<p>
Before you get started however, you may need to arrange for some login
accounts.  You can get that process started now; then, while you are
waiting for the accounts to be set up, you can get started on the
software download process.  Now consider these questions:
</p>

<dl>
  <dt> <a name="svnlogin"><em>Will you be updating or checking code into the
       code repository?</em></a>  </dt> 
  <dd> If so, then you will need a login to
       <code>svn.lsstcorp.org</code>.  Contact David Gehrig (dgehrig at
       ncsa.uiuc.edu) for this.  </dd>
  <dt> <a name="traclogin"><em>Will you be submitting bug
       reports?</em></a> </dt> 
  <dd> If so, then you will need a login for the
       <a href="http://dev.lsstcorp.org/trac/">Trac issue tracking
       site</a>.  Again, please contact David Gehrig (dgehrig at
       ncsa.uiuc.edu).
</dl>

<a name="lsst_home">
<h2>2. Building your LSST_HOME: the Standard LSST Software Stack</h2></a>

<h3>Before you start</h3>
Check to be sure that you have the prerequisite software installed
for <a href="http://dev.lsstcorp.org/trac/wiki/InstallingOnLinux">Linux</a>
or <a href="http://dev.lsstcorp.org/trac/wiki/InstallingOnMacintosh">Macintosh</a>.

<p>
In this section, we will download and install the standard software
stack, or LSST_HOME.  You will typically treat this as a read-only
area, updating it only when new releases are announced.  
</p>

<p>
It may be the case that you are developing on a shared system where
the software stack has already been installed for you.  If so, you can
skip this section. 
</p>

<p>
In this section, you will make your first encounter with our primary
product for managing LSST software: EUPS.  EUPS is to select and keep
track of the different versions of our software packages and how they
depend on other packages.  It includes the ability to download the
packages from the <a href="http://dev.lsstcorp.org/pkgs">LSST
development server, <code>dev.lsstcorp.org</code></a>
and install them on your machine.  
<!-- Details on how these tools work together are described further in 
the "LSST Build and Operation Systems" manual. -->
</p>

<a name="lh_recipe">
<h3>2.1.  Step-by-step Instructions</h3></a>

<p>
To create your <code>LSST_HOME</code> area, follow
this recipe:
</p>

<ol>
  <li> <strong><a name="lh_recipe0">Unset your previous LSST
       environment. </a></strong>

       <p>
       If you have already once installed the software stack, you
       should be sure unset your environment variables for that
       stack.  To do this, you can type (after the <code>%
       </code> prompt) one of the following:
       </p>
       
<p class="code">% unsetenv LSST_HOME EUPS_PATH   # for tcsh users
% unset LSST_HOME EUPS_PATH      # for bash users</p></li>
       
  <li> <strong><a name="lh_recipe1">Create the root directory for the LSST
       installation. </a> </strong>

       <p>
       The home of the LSST installation is your choice.  (Just don't
       use the same location as a previous LSST installation unless
       you move it out of the way first.)  For the convenience of
       typing, you can set the LSST_HOME environment variable now:
       </p>

<p class="code">% setenv LSST_HOME /the/LSST/installation/root   # for tcsh users
% export LSST_HOME=/the/LSST/installation/root   # for bash users</p>

       <p>
       Now create and change into this directory:
       </p>

       <p class="code">% mkdir -p $LSST_HOME; cd $LSST_HOME</p>
       </li>

  <li> <a name="lh_recipe2"><strong>Download and execute the
       installation setup script.</strong></a>

<p class="code">% curl -o newinstall.sh http://dev.lsstcorp.org/dmspkgs/newinstall.sh
% bash newinstall.sh LSSTPipe</p>

       <p>
       Now get a beverage, go to lunch, or work on that paper as this step will
       take about 60 minutes.  
       </p>

<blockquote class="note">
<strong>Note:</strong><br />
If you do not have <code>curl</code> on your machine, you can use
<code>wget</code> instead, as in:
<p class="code">% curl -o newinstall.sh http://dev.lsstcorp.org/dmspkgs/newinstall.sh
curl: Command not found.
% <strong>wget http://dev.lsstcorp.org/dmspkgs/newinstall.sh</strong>
% bash newinstall.sh LSSTPipe</p>
</blockquote>

       <p>
       This script has two phases to it.  First, the script will
       create some directories that will contain installed software
       and then install some core or <em>foundation</em> software
       packages.  The first of these packages is the EUPS tool, which
       we use to keep track of the packages we install.  Next it
       proceed to install other package that are important for
       downloadin, building, and installing packages.  This includes
       our designated version of Python, our "configure-and-make" software,
       SCons, and some specialized build utilities.  
       </p>

       <p>
       If you had not included the
       <code>LSSTPipe</code> argument, the 
       script would end once the core infrastructure packages were
       installed; with arguments, the script will enter its second
       stage.  Each argument is the name of a package to install
       (along with all its dependencies).
       <code>LSSTPipe</code> is a "pseudo-package"
       that represents all of the packages needed for development and
       execution of the LSST pipelines.  Note that the packages that
       make up this set will change as data challenge development
       proceeds.  You can download the latest packages at any type
       later using the <code>lsstpkg</code> tool as
       described in section 2.3 below. 
       </p>

</ol>

When this step is complete, you will have an installed LSST software
stack.  If you want to get going using the stack, you need to load the
software environment:

<p class="code">% source loadLSST.csh    # for tcsh users
% source loadLSST.sh     # for bash users</p>

(See section 4 for more details.)
       
<a name="lh_results">
<h3>2.2.  What You've Created</h3></a>

If the above installation process completes successfully, then you
should notice the following:

<p class="code">% ls
_build_  eups  Linux  loadLSST.csh  loadLSST.sh  newinstall.sh  ups_db
</p>
       
<p>
This directory is what we refer to as the
<code>LSST_HOME</code>.  Everything thing that was
installed can be found below this directory.
</p>

<p>
In summary, the contents include:
<ul>
  <li> <code>Linux</code>,
       <code>Linux64</code>, or
       <code>DarwinX86</code>: a directory 
       that represents your platform flavor (more on this below).  </li>
  <li> <code>eups</code>: the EUPS package that keeps
       track of all the installed packages.  </li>
  <li> <code>ups_db</code>:  the data directory used
       by EUPS to keep track of the software. </li>
  <li> <code>loadLSST.csh</code> and
       <code>loadLSST.sh</code>: 
       the environment initialization scripts.  </li>
  <li> <code>_build_</code>: a scratch directory used
       for building packages before they are installed.  </li>
  <li> <code>newinstall.sh</code>:  the script
       you just ran. </li>
</ul>
</p>

The <code>loadLSST.csh</code> and
<code>loadLSST.sh</code> are scripts that when
"sourced", loads the basic LSST software environment:  

<p class="code">% source loadLSST.csh    # for tcsh users
% source loadLSST.sh     # for bash or zsh users</p>

<p>
A user would usually do this at the beginning of a session, either
explicitly or via a shell "rc" file (see section 4).
</p>

The "flavor" directory--usually called 
<code>Linux</code>,
<code>Linux64</code>, or 
<code>DarwinX86</code>--is where all of the
LSST software packages (other than EUPS) can be found.  When you load
the LSST environment, an environment variable called
<code>LSST_PKGS</code> is set to this directory:

<p class="code">% echo $LSST_PKGS
/the/LSST/installation/root/Linux</p>

<blockquote class="note">
<strong>Note:</strong><br />
If you want to include software stacks for multiple platforms
under the same <code>LSST_HOME</code> directory, then
the directory would contain one directory for each platform.
</blockquote>

<p>
Inside the flavor directory, you will find the installed LSST
packages, looking something like this:
</p>

<p class="code">% ls Linux
afw          daf_base         external  pex_exceptions  sconsUtils
ap           daf_data         lsst      pex_harness     security
base         daf_persistence  lssteups  pex_logging     utils
ctrl_events  detection        mops      pex_policy      
</p>

<p>
These are primarily package LSST packages--that is, packages written
by the LSST DM team.  The <code>external</code>
sub-directory contains all of the 3rd party software (e.g. Python,
swig, scons, boost, wcslib, etc.).
</p>

<p>
Each package (be it an LSST package or 3rd party) has its own
named directory which contains one or more subdirectories named
after the package version:
</p>

<p class="code">% ls $LSST_PKGS/external/python
2.5.2</p>

<p>
If multiple versions are installed, there will be one version
subdirectory for each.
</p>

<a name="lh_install">
<h3>2.3. Installing Additional Packages</h3></a>

As LSST development proceeds, new packages or new versions of packages
will become available on the LSST software distribution server.  To
install these new packages, you can use the tool,
<code>lsstpkg</code>.  For example, to install a specific version of
some package, such as version 1.35.0 of the <code>boost</code> package, you
might type,

<p class="code">% <strong>lsstpkg install boost 1.35.0</strong>
eups distrib install boost 1.35.0-1
Required product termcap 1.3.1 already installed
Required product tcltk 8.5a4 already installed
Required product readline 5.2 already installed
Required product python 2.5.2 already installed
now installing boost 1.35.0
Version: svn
Setting up environment (via ./eupssetups.sh)...
/usr/bin/curl http://dev.lsstcorp.org/dmspkgs/external/boost/1.35.0/boost_1_35_0.tar.gz > boost_1_35_0.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 27.2M  100 27.2M    0     0  7198k      0  0:00:03  0:00:03 --:--:-- 7257k
boost_1_35_0.tar.gz
tar zvxf boost_1_35_0.tar.gz
./configure --prefix=/home/lsst/dmspkgs/Linux64/external/boost/1.35.0
/usr/bin/make
/usr/bin/make install
Emptying the build directory
rmdir /home/lsst/dmspkgs/_build_/boost-1.35.0
Package boost 1.35.0 installed successfully
</p>

<p>
If you get a message complaining that the <code>lsstpkg</code> command
is not found, then you don't have the environment fully setup up.
Sourcing the <code>loadLSST</code> script should fix this.  
</p>

<p>
You don't have to specify the version.  If you leave it off, as in:
</p>

<p class="code">lsstpkg install boost</p>

<p>
you will get the so-called "current" version--that is, the version
that is currently recommended by the project.  
</p>

<p>
As the first line of its output is meant to suggest, the <code>lsstpkg</code> 
command is a thin layer around the <code>eups distrib</code> command.
To learn more about the eups tool, see <a href="#eups">section 7.1</a>.
</p>

<blockquote class="note">
<strong>Can one use '<code>eups distrib</code>' instead of
'<code>lsstpkg</code>'?</strong><br /> 
Yes.  <code>lsstpkg</code> is just a convenience command.  The main
reason for using <strong>lsstpkg</strong> is that it guarantees that
LSST extensions to the EUPS tool have been setup; if they have not
been, <code>eups distrib</code> will fail.  So, if you use <code>eups
distrib</code> directly, we recommend that you be sure to first
setting up the <code>lsst</code> package (type: <code>setup lsst</code>).
</blockquote>

Finally, if you want to know what packages are available from the
server, you can use <code>lsstpkg</code> to list them:

<p class="code">% <strong>lsstpkg list boost</strong>
eups distrib list boost
...
% <strong>lsstpkg list boost</strong>
eups distrib list
...
</p>

<a name="lh_prob">
<h3>2.4.  If Something Goes Wrong</h3></a>

<p>
When a package fails to install, you should see output that ends like
this:
</p>

<p class="code">...
lssteupsbuild.sh: scons install failed; see .../_build_/ip_diffim-3.0/ip_diffim-3.0/build.log for details
Failed to build and install ip_diffim-3.0.tar.gz
</p>

<p>
Prior to these final messages, you should also see some indication of
what went wrong, like the last error messages that were encountered
before the install process exited.
</p>

<p>
Consider installation failures as falling into two categories of
possible causes: 
<ul>
  <li> environmental problems on your machine or in the network, such as 
       <ul>
         <li> no space left on disk, </li>
         <li> problems connecting to
              <code>dev.lsstcorp.org</code>, </li>
         <li> the LSST development environment improperly set
              (e.g. because <code>loadLSST.(c)sh</code> has not been
              sourced). </li>
         <li> your operating system installation is missing some
              prerequisite libraries that we were expecting to be
              there by default.  
       </ul> </li>
  <li> problems with the configuration of the
       <code>dev.lsstcorp.org</code> server
       <ul>
         <li> most typically, a particular build script contains a
              bug or needs further modification to support your
              platform.  
       </ul>
</ul></p>

<p>
For problems in latter category, please issue a bug report via the
Trac system, or (if you are not yet familiar with Trac or don't have
permission to submit bugs), report the problem to Ray Plante (rplante
at ncsa.uiuc.edu).  Include in your report the output from the
<code>lsstpkg</code> command.   
</p>

<p>
You might also consult our
<a href="http://dev.lsstcorp.org/trac/wiki/Installing">Platform
support page</a> to make sure that you have the necessary prerequisite
libraries install.  Follow the link to the page on your architecture
(Linux or Macs) and find the section for your OS distribution.  
</p>

<p>
If you are inclined to investigate the problem further on your
platform (always appreciated), note that you can find the uninstalled
package under <code>$LSST_HOME/_build_</code>.  Usually you must
descend two directories named after the failed package
(e.g. "ip_diffim-3.0") to find the build log called
<code>build.log</code>.  
</p>

<p>
If the problem has been corrected (either on the server or with your
OS), you restart the installation process where you left off without
having to reinstall packages which were previously installed
correctly.  Before you restart though, it's a good idea to first
remove the package that failed.  This is also done with the
<code>lsstpkg</code> command.  For example, suppose you had a failure
while installing Boost.  First, <code>lsstpkg</code> will require that
you specify the version of the package, so you will need to determine
that.  This is obvious from the error message shown above (the version
was "3.0").  To remove the package, type:
</p>

<p class="code">% lsstpkg remove ip_diffim 3.0
</p>

<p>
You can now restart <code>lsstpkg</code>:
</p>

<p class="code">% lsstpkg fetch LSSTPipe
Installing 0.1 of LSSTPipe
Product termcap (version 1.3.1, flavor Linux) is already declared
Product tcltk (version 8.5a4, flavor Linux) is already declared
Product readline (version 5.2, flavor Linux) is already declared
...
</p>

<a name="sandbox">
<h2>3.  Creating a Development Sandbox</h2></a>

<p>
If you prefer that <code>LSST_HOME</code> be read-only,
then you will want a <code>LSST_DEVEL</code>
directory where you can install new, developmental, or experimental
versions of packages.  If your <code>LSST_HOME</code>
is on your personal machine which you do not share with other users,
you may wish to not bother with a
<code>LSST_DEVEL</code> directory.  
</p>

<p>
The <code>LSST_DEVEL</code> tree has exactly the same
structure as <code>LSST_HOME</code>.  The main
difference is that <code>LSST_DEVEL</code> is not
expected to have all of the packages installed but rather only the
ones that might override what is in
<code>LSST_HOME</code>.  
</p>

<p>
The <code>build</code> package includes a tool,
<code>mksandbox</code>, to help setup your own
<code>LSST_DEVEL</code> area.  To create the
directory, follow this recipe:
</p>

<p class="code">% setup build
% cd $HOME/lsstsandbox   # choose your desired location
% mksandbox
% ls
Linux ups_db</p>

Done.

<a name="rcfile">
<h2>4.  Updating Your Shell RC File</h2></a>

<p>
If you are going to do regular development, then you will probably
find it convenient to update your shell "rc"
file--e.g. <code>.cshrc</code> or <code>.bashrc</code>--to automate
the setting up of the LSST environment.  This update is optional,
however; see the discussion below for details.  
</p>

Here's a sample of what you might put in your .cshrc (or .tcshrc) file
if you use <code>csh</code> (or <code>tcsh</code>) as your default
shell:

<p class="code"># Load the LSST environment
#
# set useful environment variables.  None of these are required, but they 
# are helpful.  
#
setenv LSST_HOME /the/installation/root4/LSST
setenv LSST_DEVEL /my/LSST/sandbox

#
# the setlsst command loads the environment on demand
#
alias setlsst source $LSST_HOME/loadLSST.csh

# 
# uncomment this line to load the LSST environment automatically when
# the shell starts
#
# setlsst</p>

Alternatively, if you use <code>bash</code>:

<p class="code"># Load the LSST environment
#
# set useful environment variables.  None of these are required, but they 
# are helpful.  
#
export LSST_HOME=/the/installation/root4/LSST
export LSST_DEVEL=/my/LSST/sandbox/$EUPS_FLAVOR 

#
# the setlsst command loads the environment on demand
#
alias setlsst=source $LSST_HOME/loadLSST.sh

# 
# uncomment this line to load the LSST environment automatically when
# the shell starts
#
# setlsst</p>

Note these comments:
<ul>
  <li> As the comments mention, you do not have to define the
       environment variables; they are merely a convenience.  The
       important part of loading the environment is sourcing the
       <code>loadLSST.csh</code> (or <code>loadLSST.sh</code>) file.
       Any needed environment variables (namely,
       <code>$LSST_HOME</code> and <code>$EUPS_PATH</code>) are set to
       defaults.  
       </li>

  <li> If you chose not to create a sandbox, do not define
       <code>LSST_DEVEL</code>.  New packages will automatically be
       installed into <code>$LSST_HOME</code> instead.  </li>

  <li> If you uncomment the last line, the LSST environment will be
       loaded by default with the start of each new shell.  Doing this
       automatically or manually is a matter of your preference.
       </li>

  <li> These lines are just suggestions; you are welcome to specialize
       them to your taste.  For instance, you may add EUPS
       <code>setup</code> commands to select certain packages by
       default (see <a href="#eups">section 7.1</a> for details).
       </li>

  <li> If you have other EUPS-managed directories besides
       <code>$LSST_HOME</code> and
       <code>$LSST_DEVEL</code>, then you should also
       explicitly set the <code>EUPS_PATH</code>
       variable, e.g.

       <p class="code">% setenv EUPS_PATH ${$LSST_DEVEL}:${$LSST_HOME}:/other/eups/directory   # tcsh
       
% export EUPS_PATH=${$LSST_DEVEL}:${$LSST_HOME}:/other/eups/directory   # bash</p>
</ul>


<a name="testdata">
<h2>5.  Downloading Test Data</h2></a>

<blockquote class="note">
<strong>Note:</strong><br />
This section is under construction...
</blockquote>

<a name="srcco">
<h2>6.  Checking Out LSST Source Code</h2></a>

<p>
We use <a href="http://www.subversion.org/">Subversion (svn)</a> as our 
version control system, and our repository is located at
<code>svn.lsstcorp.org</code>.  We restrict access to
the svn tree using SSH.  Thus, in order to check out code, you will need a
login to our svn server.  If you haven't requested a login already, consult
<a href="#svnlogin">these instructions</a> for more information.
</p>

<p>
Once you have a login, you should test to make sure it works by
logging into <code>svn.lsstcorp.org</code> with ssh.
Next, you will probably want to set up some ssh keys so that you can
log in without typing your password.  This is not require; however, if
you don't set this up, svn will repeatedly and inconveniently ask you
to type in your password which can be painful.  For detailed
instructions on this, consult <a href="">"Setting up SSH for
Subversion" (Document-1808)</a> in the Docushare repository.  
</p>

<a name="svnlsst">
<h3>6.1  Using Subversion for LSST Development</h3></a>

<a name="svninstall">
<h4>6.1.1  Installing Subversion</h4></a>

<p>
The client program you will use is called <code>svn</code>, so if you
do not have this program on your system, you will need to install it.  The
Subversion source code is available from
<a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a>
and builds quite readily under Linux.  This site also provides
pointers to binary distributions as well.  
</p>

<a name="svnrun">
<h4>6.1.2  Running the SVN Client</h4></a>

<p>
If you are already familiar with using the Subversion client,
<code>svn</code>, then skip to <a href="#svnstruct">the next section,
"Repository Organization"</a>.  Note that section 6.2 provides a
<a href="#svnsurvival">survival guide to SVN.</a> 
</p>

<p>
Access to the LSST subversion repository is through use of ssh.  The general
syntax to access the LSST repository is:
</p>

<p class="code">% svn <i>command</i> svn+ssh://svn.lsstcorp.org/<i>path/to/code</i></p>

<p>
The svn+ssh prefix tells subversion to use the ssh protocol to connect
and once connected, run the subversion server to access the repository. 
</p>

<p>
For those familiar with CVS, there is no mechanism for setting the
default root directory of the repository in subversion; however, for your
convenience two environment variables are set for you when you source
the <code>loadLSST.*sh</code> file:
<ul>
  <li> <code>$LSST_SVN</code> -- svn+ssh://svn.lsstcorp.org </li>
  <li> <code>$LSST_DMS</code> -- svn+ssh://svn.lsstcorp.org/DMS </li>
</ul>
</p>

<p>
This makes working with the SVN server a bit easier:
</p>

<p class="code">% svn <i>command</i> $LSST_SVN/<i>path/to/code</i></p>

<p>
We can now try a simple command to list the top level directories in
the repository
</p>

<p class="code">% svn list $LSST_SVN
DC2/
GilTest/
branches/
tags/
trunk/
</p>

<a name="svnstruct">
<h4>6.1.2  Repository Organization</h4></a>

<p>
The software being developed for the DC3 can all be found under a
top-level directory called <code>DMS</code>.  Under that can be found
directories representing a package <em>or</em> a set of related packages:
</p>

<p class="code">% svn list $LSST_DMS    # same as list $LSST_SVN/DMS
afw/
analysis/
ap/
astrocal/
base/
cat/
catf/
coadd/
ctrl/
daf/
detection/
devenv/
ip/
mops/
pex/
photocal/
report/
security/
testdata/
utils/
</p>

<blockquote class="note">
<strong>Remember:</strong><br />
<code>$LSST_DMS</code> is an environment variable we set to be
<code>svn+ssh://svn.lsstcorp.org/DMS</code>.  
</blockquote>

<blockquote class="note">
<strong>Note:</strong><br />
You may be prompted multiple times for your ssh password.
This can be avoided by either using ssh-agent to manage your ssh
session or by installing an ssh public key into the
.ssh/authorized_users file in your home directory on the
svn.lsstcorp.org server.  See <a href="">"Setting up SSH for
Subversion" (Document-1808)</a> for details.
</blockquote>

<p>
You may check out the entire DMS tree; however, it is recommended that
you really only check out the packages you plan to work on. 
</p>

<p>
A package directory is one that contains four standard subdirectories:
</p>

<p class="code">% svn list $LSST_SVN/DC2/afw
branches/
tags/
tickets/
trunk/
</p>

<p>
These sub-trees play the following roles:
</p>

<dl>
  <dt> <code>trunk</code> </dt>
  <dd> Contains the main line of development.  This is the version
       most developers work with. </dd>

  <dt> <code>branches</code> </dt>
  <dd> Contains experimental versions of the package.  Sometimes a
       developer would like to test out a complex idea on a package
       without affecting the main-line development.  In this case, she
       makes a copy of the package into a subdirectory of
       <code>branches</code> and checks in modifications there.
       Later, if the developer wants to bring the new ideas into the
       main-line, there is a merging process.  (See "LSST Build and
       Test Systems" for details.) </dd>

  <dt> <code>tags</code> </dt>
  <dd> Contains released version of the package.  When a development
       milestone is reached, the developer creates a versioned release
       of the package by copying the trunk into a subdirectory of
       <code>tags</code> named after the version--e.g.,
       <code>tags/1.0</code>.  (See <a href="#release">section 7.4,
       "Creating a Package Release"</a> for details.)</dd>

  <dt> <code>tickets</code>
  <dd> Contains versions where bugs and enhancements are being
       addressed.  When someone issues a bug report or an enhancement
       request, a "ticket" is generated in the
       <a href="http://dev.lsstcorp.org/trac/">bug tracking system</a>, 
       represented by a ticket number.  When a developer addresses the 
       issue, she makes a copy of the package in a subdirectory named 
       after the ticket number.  After the code has passed review, the 
       changes are merged into the trunk.

       <blockquote class="note">
       <strong>Note:</strong><br />
       Normally, all development takes place under a
       tickets directory.  This will ensure that the trunk always
       contains working, reviewed code.
       </blockquote>
</dl>

<p>
If a directory does not contain these subdirectories, then the package
represents a set of related packages, e.g.:
</p>

<p class="code">% svn list $LSST_DMS/pex
exceptions/
harness/
logging/
policy/
% svn list $LSST_DMS/pex/logging
branches/
tags/
tickets/
trunk/
</p>

<a name="svncopkg">
<h4>6.1.3  Checking Out a Package</h4></a>

<p>
As a start, we will establish our SVN development tree and can check
out the framework package, <code>fw</code>, into it.
Let's call this tree <code>DMS</code>:
</p>

<p class="code">% mkdir DMS; cd DMS</p>

<p>
Now to check out the framework package:
</p>

<p class="code">% svn co $LSST_DMS/afw/trunk afw</p>

<blockquote class="note">
<strong>Note:</strong><br />
You may be prompted multiple times for your ssh password.
This can be avoided by either using ssh-agent to manage your ssh
session or by installing an ssh public key into the
.ssh/authorized_users file in your home directory on the
svn.lsstcorp.org server.  See <a href="">"Setting up SSH for
Subversion" (Document-1808)</a> for details.
</blockquote>

<p>
This checks out the main trunk of the <code>fw</code>
package into a new directory called fw:
</p>

<p class="code">% ls afw
doc  examples  include  lib  python  SConstruct  src  tests  ups
</p>

<p>
You are now ready to hack!  Proceed to <a href="#work">section 7,
"Working with LSST packages"</a> to learn more about building an LSST
package.  
</p>

<a name="svnsurvival">
<h3>6.2  An SVN Survival Guide</h3></a>

<a name="svnhelp">
<h4>6.2.1.  Helpful Documentation</h4></a>

<p>
The Subversion command-line client svn interface is modeled after CVS. See
also svn help for more commands and options, as well as the on-line book at
<a href="http://svnbook.red-bean.com/nightly/en/svn-book.html">http://svnbook.red-bean.com/nightly/en/svn-book.html</a> 
Section 3 ("Guided Tour") which is especially useful for getting started.  
</p>

<a name="svndcvs">
<h4>2.2.  Differences with CVS</h4></a>

<p>
If you are familiar with CVS, you should note these behavioral
differences:
</p>

<ul>
  <li> There is no equivalent to environment variable, <code>CVSROOT</code>.
  <li> With Subversion, revision numbers are assigned globally, not on a  
         per-file basis.  Everytime a commit is done, the revision of the 
         entire repository increments.                                    
  <li> A commit command is guaranteed atomic, regardless of the number    
         of files being committed; if anything goes wrong, none of the    
         files will be committed.                                         
  <li> When update conflicts are detected, additional local versions are  
         created to help you sort out the conflict (see below).
</ul>

<a name="svnusage">
<h4>2.3.  Common Usage</h4></a>

<p>
In the examples given below, it is assumed that the SVN environment
variable has been set to svn+ssh://svn.lsstcorp.org/ as
suggested above.  
</p>

<ol>
  <li> Checkout files

       <p class="code">svn checkout <i>URL PATH</i></p>

       <p>
       This downloads the part of the repository pointed to by <i>URL</i>
       into the local directory given by <i>PATH.</i>
       </p>

       <p>
       <strong>Example:</strong> Check out a package for normal
       development and put it into a local directory.  Note
       that the trunk represents the leading edge of main development,
       excluding special branches or tagged sets.
       </p>

       <p class="code">% svn checkout $SVN/DC2/fw/trunk fw</p>

       <p>
       Example:  Check out a particular release of a package
       </p>

       <p class="code">% svn checkout $SVN/DC2/fw/tags/0.2 fw-0.2</p>
       </li>

  <li> Adding and removing files or directories

       <p class="code">svn add <i>PATH</i>
svn delete <i>PATH</i>
svn commit -m "<i>LOG-MESSAGE</i>" <i>[</i>--recursive<i>] PATH ...</i>  </p>

       <p>
       The first two commands above update your local copy of the code tree,
       while the third line commits the local changes to the repository.  
       </p>

       <p>
       <strong>Example:</strong> add a new source file and delete an
       old one. 
       </p>

       <p class="code">% svn add foo.py
% svn delete bar.py
% svn commit -m "preferring foo.py over bar.py" foo.py bar.py</p>

       <p>
       Here's another way to do the commit that catches all pending
       changes under a directory:
       </p>

       <p class="code">% svn commit -m "preferring foo.py over bar.py" --recursive .</p>

       <p>
       An easy way to add an entire package tree to the repository is with
       the import command:
       </p>

       <p class="code">svn import <i>PATH URL</i></p>

       <p>
       This recursively imports a copy of <i>PATH</i> to repository.
       </p>

       <p>
       <strong>Example:</strong>  add in a new package, code and all:
       </p>

       <p class="code">% svn import mypkg $SVN/DC2/mypkg/trunk</p>
       </li>

  <li> Updating existing files

       <p class="code">svn update <i>[PATH ...]</i>
...
svn commit -m "<i>UPDATE-MESSAGE</i>" <i>[PATH ...]</i></p>

       <p>
       The update command downloads any changes to the files or
       directories pointed to by PATH since the last time you checked out
       or updated them.  The behavior is much like in CVS.  
       </p>    

       <p>
       <strong>Example:</strong>  update and commit some files
       </p>

       <p class="code">% svn update foo.c bar.c choo.c
U  foo.c
G  bar.c
C  choo.c</p>

       <p>
       In this example, an updated version of <code>foo.c</code> was
       downloaded.  <code>bar.c</code> was also updated; however,
       <code>svn</code> noticed that your local version included
       uncommitted changes that you made, and these changes were
       merged into the updated version.  With <code>choo.c</code>, the
       merge was not successful, and special tags were inserted that
       mark where you need to resolve conflicts between your local
       changes and the changes downloaded from the repository.  
       </p>

       <p>
       The difference in behavior from CVS is that in the case of a
       conflict, svn may create additional versions of the file to help
       with resolving the conflicts:
       </p>
       
       <table border="0" cellpadding="0" cellspacing="0">
         <tr><td valign="middle"><code>choo.c</code></td>
             <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
             <td valign="middle">the updated version with conflicts tagged</td></tr>
         <tr><td valign="middle"><code>choo.c.mine</code></td>
             <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
             <td valign="middle">your pre-updated version</td></tr>
         <tr><td valign="middle"><code>choo.c.r1</code></td>
             <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
             <td valign="middle">the committed version prior to your updates</td></tr>
         <tr><td valign="middle"><code>choo.c.r2</code></td>
             <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
             <td valign="middle">the committed version to be merged with your
                 version</td></tr>
       </table>

       <p>
       After resolving conflicts and making new changes, you can
       commit:  
       </p>

       <p class="code">% svn commit -m "bug fix: memory leak" foo.c bar.c choo.c</p>

       <p>
       If svn detects that someone else has checked in any changes since
       you did your update, the entire commit for all three files will
       fail (unlike with CVS).  In this case, you should run the update
       command again on those files and then resolve any conflicts before trying
       another commit.  
       </p>
       </li>

  <li> Checking the status of directory and files

       <p>It's often useful to peruse the differences between your local
       files and those in the repository without actually doing an
       update.  These command are useful for doing this.  
       </p>

       <dl>
         <dt> <code>svn status <i>[PATH ...]</i></code> </dt>
         <dd> lists all files that are not in sync with repository and tags
              its state (e.g. needs updating, in conflict, etc.).
              </dd>

         <dt> <code>svn diff <i>[PATH ...]</i></code> </dt>
         <dd> shows differences between your local version and the version
              in the repository.</dd>

         <dt> <code>svn revert <i>[</i>--recursive<i>] [PATH ...]</i></code>
              </dt>
         <dd> undo any uncommitted changes, adds, deletes, copies, and
              moves of the listed files or directories.  </dd>
       </dl>

       <p>
       For more information on these commands see the
       <a href="http://svnbook.red-bean.com/nightly/en/svn-book.html">
       SVN book</a>, Section 3 (Guided Tour/Examine Your Changes) and
       Section 9 (Subversion Complete Reference).
       </p>
       </li>
</ol>

<a name="work">
<h2>7.  Working With LSST Packages</h2></a>

<a name="eups">
<h3>7.1  An Introduction to EUPS</h3></a>

<p>
EUPS is a tool that allows us to have installed multiple versions of
our packages on the same machine and provides us with the ability to
easily switch between them.  It does this by manipulating key
environment variables, including <code>PATH</code>,
<code>PYTHONPATH</code>, and <code>LD_LIBRARY_PATH</code>, so that our
applications always finds the correct, desired version.  It keeps
track of dependencies between packages as well, so that when a
particular version of a package is selected, all of the correct
versions of the dependent packages are chosen as well.  
</p>

<p>
This section provides you with a quick introduction to the EUPS tools
and we use them in LSST development.  For detailed information, you
can consult the
<a href="http://lsstdev.ncsa.uiuc.edu:8100/trac/wiki/EupsManual">EUPS
Manual</a>.  Note also that all the EUPS commands accept a
<code>--help</code> or <code>-h</code> option:
</p>

<p class="code">% eups declare --help
Wink lsst5 11: eups declare -h
Usage:
    eups [commonOptions] declare [options] [product] [version]

Declare a product

Options:
   -c, --current           Declare product current
   -Z, --database   arg    Use this products path. Default: $EUPS_PATH
                           Alias: --with-eups
       --debug      arg    Permitted Values: raise
   -f, --flavor     arg    Use this flavor. Default: $EUPS_FLAVOR or `eups flavor`
   -F, --force             Force requested behaviour
   -h, --help              Print this help message
   -M               arg    Import the given table file directly into the database
                           (may be "-" for stdin)
   -n, --noaction          Don't actually do anything
   -r, --root       arg    Location of product being declared
   -z, --select-db  arg    Select the product paths which contain this directory.
                           Default: all
   -m, --table      arg    Use table file (may be "none") Default: product.table
   -v, --verbose           Be chattier (repeat for even more chat)
   -V, --version           Print eups version number and exit
</p>

<a name="eupsfind">
<h4>7.1.1  How EUPS Finds Packages</h4></a>

<p>
The most important environment variable used by EUPS is
<code>EUPS_PATH</code>.  This variable contains a colon-separated list
of directories where it will look for information about installed packages.
In particular, each directory should contain a EUPS database,
represented by a subdirectory called <code>ups_db</code>.  (Typically, a
<code>EUPS_PATH</code> directory also contains the actual packages
registered in the database, but it doesn't have to.)   When you select
a package with the EUPS command, <code>setup</code>
(<a href="#eupssetup">section 7.1.3</a>), the EUPS_PATH directory
databases are searched in order and the first one matching the request
is selected.  
</p>

<p>
The <code>EUPS_PATH</code> also plays an important role when
registering new packages with EUPS using <code>eups declare</code>
(<a href="#eupsdeclare">section 7.1.4</a>) and installing packages
with <code>eups distrib</code> (<a href="#lh_recipe">section
2.1</a>).  In both cases, only the first directory is used by default;
the others are ignored.  That is, <code>eups declare</code> will
register any new packages into the database belonging to the first 
<code>EUPS_PATH</code> directory, and <code>eups distrib</code> will
install new packages below the first <code>EUPS_PATH</code>
directory. 
</p>

<p>
In <a href="#rcfile">section 4</a>, we recommended that you set the
value <code>EUPS_PATH</code> variable to
<code>${LSST_DEVEL}:${LSST_HOME}</code>.  
</p>

<p>
The <code>EUPS_FLAVOR</code> directory contains the name of your
platform (currently, either "Linux" or "Darwin").  EUPS uses the value
of this variable to select only packages that have be registered as
supporting your platform.  If it is not set, EUPS attempts to
auto-detect your platform.  
</p>

<p>
Finally, the <code>EUPS_PKGROOT</code> is used only by <code>eups
distrib</code> to provide a default base URL from which packages can
be downloaded and installed.  You do not have to explicitly set this
as it is done automatically when you load the LSST environment.  
</p>

<p class="code">% echo $EUPS_PKGROOT 
http://dev.lsstcorp.org/pkgs</p>

<a name="eupslist">
<h4>7.1.2  Seeing What's Available</h4></a>

<p>
The <code>eups list</code> command is useful for seeing what versions
of packages are available.  For example,  
</p>

<p class="code">% eups list
activemqcpp           2.1-RC1           Current
afw                   3.0               Current
ap                    3.0               Current
base                  3.1               Current Setup
boost                 1.36.0            Current
cfitsio               3006.2            Current
ctrl_events           3.0               Current
daf_base              3.0               Current
daf_data              3.0               Current
daf_persistence       3.1.1             Current
detection             3.0               Current
doxygen               1.5.4             Current
eups                  LOCAL:/the/LSST/installation/root/eups/1.0.4       Setup
ip_diffim             3.0.1             Current
lsst                  0.3               Current Setup
lssteups              0.3               Current Setup
minuit                1.7.9             Current
mops                  3.0               Current
mpich2                1.0.5p4           Current
mysqlclient           5.0.45+1          Current
numpy                 1.0.1             Current
pex_exceptions        3.0               Current
pex_harness           3.0.1             Current
pex_logging           3.0               Current
pex_policy            3.0.1             Current
python                2.5.2             Current Setup
scons                 1.20              Current Setup
sconsDistrib          0.98.5            Current Setup
sconsUtils            1.20              Current Setup
security              3.0               Current
swig                  1.3.34            Current
swig                  1.3.36    
tcltk                 8.5a4             Current Setup
utils                 3.0               Current
vw                    1.0.1+3           Current
vwlapack              1.0.0             Current
wcslib                4.2-lsst.2        Current
xpa                   2.1.7b2           Current
</p>

<p>
The "<code>Current</code>" label in the third column indicates that
that particular version of a package has been flagged as the current
default version.  If you do not specify a version to the
<a href="#eupsselect"><code>setup</code> command</a>, then this
flagged version will be selected.  If the third column also includes a
"<code>Setup</code>" label, then that particular version has already
been selected with the <a href="#eupsselect"><code>setup</code>
command</a>.  (If you sourced the <code>loadLSST.*sh</code> start-up
script, then several packages will be pre-selected for you.)
</p>

<p>
You can restrict the listing output to a specific package by providing
the package's name to <code>eups list</code>.  Add a version string,
and the listing will be restricted to that version.  
</p>

<p class="code">% eups list afw
   3.0                   Current
% eups list afw 3.0
   0.2                   Current</p>

<p>
Add a <code>-v</code> (or <code>--verbose</code>), and the directory
where the package is installed is shown as well.  
</p>

<p class="code">% eups list fw -v
   3.0          /the/LSST/installation/root/Linux  /the/LSST/installation/root/Linux/fw/3.0            Current </p>

<p>
The first path is the <code>EUPS_PATH</code> directory where the
package was found, and the second path is the directory where that
particular version of the package is installed.  
</p>

<a name="eupsselect">
<h4>7.1.3  Selecting a Package</h4></a>

<p>
The <code>setup</code> command is used to select a particular version
of a package for use.  
</p>

<p class="code">% setup afw        # selects the version flagged as "Current"
% setup afw 3.0                    # selects version 3.0 </p>

When you select a package with <code>setup</code>, it also implicitly
selects the other packages the requested package depends on.  To see
exactly which packages those are, add a <code>-v</code> (or
<code>--verbose</code>):

<p class="code">% setup -v afw
Setting up: afw                             Flavor: Linux64    Version: 3.0
Setting up: |daf_data                       Flavor: Linux64    Version: 3.0
Setting up: | daf_persistence               Flavor: Linux64    Version: 3.1.1
Setting up: | |pex_policy                   Flavor: Linux64    Version: 3.0.1
Setting up: | | boost                       Flavor: Linux64    Version: 1.36.0
Setting up: | | |python                     Flavor: Linux64    Version: 2.5.2
Setting up: | | pex_exceptions              Flavor: Linux64    Version: 3.0
Setting up: | | |pex_logging                Flavor: Linux64    Version: 3.0
Setting up: | | | daf_base                  Flavor: Linux64    Version: 3.0
Setting up: | | | |utils                    Flavor: Linux64    Version: 3.0
Setting up: | | | | base                    Flavor: Linux64    Version: 3.1
Setting up: | | | | swig                    Flavor: Linux64    Version: 1.3.34
Setting up: | | | | doxygen                 Flavor: Linux64    Version: 1.5.4
Setting up: | |mysqlclient                  Flavor: Linux64    Version: 5.0.45+1
Setting up: | security                      Flavor: Linux64    Version: 3.0
Setting up: |vw                             Flavor: Linux64    Version: 1.0.1+3
Setting up: |cfitsio                        Flavor: Linux64    Version: 3006.2
Setting up: |wcslib                         Flavor: Linux64    Version: 4.2-lsst.2
Setting up: |xpa                            Flavor: Linux64    Version: 2.1.7b2
Setting up: | tcltk                         Flavor: Linux64    Version: 8.5a4
Setting up: |numpy                          Flavor: Linux64    Version: 1.0.1
Setting up: |minuit                         Flavor: Linux64    Version: 1.7.9</p>

<p>
The indentation of the package names indicates the hierarchy of
dependencies.  In this case, the <code>afw</code> package version 3.0
requires <code>daf_data</code> version 3.0, which in turn requires
<code>daf_persistence</code> 3.0, <code>security</code> 3.0, and,
indirectly <code>python</code> 2.5.2.  
</p>

<p>
When you select a package with <code>setup</code>, environment
variables are updated.  First, an environment variable of the form
<code><i>PRODUCT</i>_DIR</code> is set to the directory where the
selected product is installed.
</p>

<p class="code">% echo $AFW_DIR
/the/LSST/installation/root/Linux/afw/3.0</p>

Then, depending on what the package provides, other environment
variables like <code>PATH</code>, <code>PYTHONPATH</code>, and
<code>LD_LIBRARY_PATH</code> are altered.  For example,
<code>fw</code> provides a python module, so <code>setup</code> adds
its python directory to <code>PYTHONPATH</code>:

<p class="code">% echo $PYTHONPATH | sed -e 's/:/\n/g'
/the/LSST/installation/root/Linux64/afw/3.0/python
/the/LSST/installation/root/Linux64/lssteups/0.3/python
/the/LSST/installation/root/Linux64/sconsUtils/1.20/python
/the/LSST/installation/root/eups/1.0.4/bin
/the/LSST/installation/root/Linux64/base/3.1/python
/the/LSST/installation/root/Linux64/utils/3.0/python
/the/LSST/installation/root/Linux64/daf_base/3.0/python
/the/LSST/installation/root/Linux64/pex_logging/3.0/python
/the/LSST/installation/root/Linux64/pex_exceptions/3.0/python
/the/LSST/installation/root/Linux64/pex_policy/3.0.1/python
/the/LSST/installation/root/Linux64/daf_persistence/3.1.1/python
/the/LSST/installation/root/Linux64/security/3.0/python
/the/LSST/installation/root/Linux64/daf_data/3.0/python
/the/LSST/installation/root/Linux64/external/numpy/1.0.1/lib/python
% which python
/the/LSST/installation/root/Linux/external/python/2.5/bin/python</p>

<p>
<code>setup</code> also made sure we used the right version of
Python by updating <code>PATH</code>.  Note that if a different
version of a package had been previously declared, mention of the
previous version are <em>removed</em> from the environment variables
before the new version is added.  
</p>

You may un-select a package with the <code>unsetup</code> command.

<p class="code">% unsetup afw</p>

<p>
Obviously, you do not need to provide the version number when
un-selecting a package. Note that this also un-selects the other
packages it relies on.  If you still need any of those dependent
packages, you will need to run <code>setup</code> again for those
specific packages.  
</p>

<a name="eupsdeclare">
<h4>7.1.4  Registering a New Package</h4></a>

<p>
When you installed packages with <code>eups distrib</code>
(<a href="#lh_recipe">section 2.1</a>), the <code>eups declare</code>
command was run for you.  This registered each downloaded package into
an EUPS database.  On occasion however, you will have to run
<code>eups declare</code> by hand.  For example, you may want to
register a private version of package that you built from the SVN code
tree.  An invocation usually takes the following form:
</p>

<p class="code">eups declare <i>package_name version_name</i> -r <i>path/to/package</i></p>

<p>
For example,
</p>

<p class="code">eups declare fw svn -r /path/to/private/afw</p>

<p>
Note that the <i>version_name</i> can be any arbitrary string; it
simply needs to be distinct from other the other registered versions
of the package.  The <code>-r</code> tells EUPS what the root
directory for the package is (and thus what it should set, in this
case, the <code>AFW_DIR</code> variable to).  
</p>

<p>
In order to declare a package in this way, its root directory must
contain a <code>ups</code> subdirectory that contains a file of the
form <code><i>product</i>.table</code>.  This table file contains an
enumeration of the other packages that this package requires as well
as how the environment variables should be updated when the package is
selected.  In the absence of a <code>ups</code> subdirectory, you can
specify a specific table file with the <code>--table</code> (or
<code>-t</code>) option. 
</p>

<p>
If you want to declare a package as "Current", regardless of whether
it was already registered or not, add the <code>--current</code>
option to the command line:
</p>

<p class="code">% eups declare --current fw svn -r /path/to/private/afw</p>

<p>
You can also un-declare a package:
</p>

<p class="code">% eups undeclare afw svn</p>

<p>
Obviously, you do not need to mention the root directory. 
</p>

<!--
<a name="setallcurr">
<h4>7.1.4.1  Setting All Current LSST packages</h4></a>

<p>
You may wish to flag all of your packages according to what the LSST
project considers the official current versions.  This may because you
didn't use the <code>--current</code> flag when you ran <code>eups
distrib</code> or you have since made your own choices for what you
would like to be considered current.  A special tool,
<code>setallcurrent.sh</code>, is available to switch to the official
notion of what is "Current".  
</p>

<p>
To run, type:
</p>

<p class="code">% cd $LSST_HOME
% curl -o setallcurrent.sh  http://dev.lsstcorp.org/dmspkgs/setallcurrent.sh
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   297  100   297    0     0    842      0 --:--:-- --:--:-- --:--:--     0
% sh ./setallcurrent.sh</p>

<p>
This command sets the current versions by reading a file called
<a href="http://dev.lsstcorp.org/dmspkgs/current.list">current.list</a>.
<code>setallcurrent.sh</code> will run <code>eups declare
--current</code> for each package listed there that you have
installed.  Previous "current" declarations for those packages are
overridden.  
</p>

-->

<a name="build">
<h3>7.2  Building and Installing an LSST Package</h3></a>

<i>editing in progress</i>

<p>
<code>SCons</code> is the tool we use to build the
LSST packages.  To build a package, you first need to be sure you have
the LSST environment loaded.  If you haven't already, load it now:
</p>

<p class="code">% source $LSST_HOME/loadLSST.csh  # or, 'source $LSST_HOME/loadLSST.sh' for bash</p>

<blockquote class="note">
<code>Important:</code>
Sourcing this file will automatically setup the development
environment package, <code>lsst</code>.  If you do not as matter of
preference source this file, you need to explicitly setup this package
yourself: 
<p class="code">% setup lsst</p>
One of the things this does is load SCons into your environment.
</blockquote>

<p>
At this point, you should, if you haven't already, check out (using
<code>svn</code>) the LSST package you want to build;
see <a href="#snvlsst">section 6.1</a> for details.  Once you have
done this, change into the directory where you have checked out the
package.  
</p>

<p>
We now need to load into our environment all of the other packages
that this package depends on.  We do this by running a special setup
command:
</p>

<p class="code">% setup -r .</p>

<p>
This reads the EUPS table file (e.g. <code>ups/afw.table</code>) to
figure out what the dependencies and the requisite environment are.
</p>

<p>
We are now ready to use scons to build the package; to do this, simply
type <code>scons</code> in the top directory of the
package: 
</p>

<p class="code">% scons</p>

<p>
So far, we have just compiled all of the code; we haven't installed
it, yet.  And once we have installed, we'll want to declare it to EUPS
so that we can use it.  To do this, we pass the "install" and
"declare" targets to the <code>scons</code> command:
</p>

<p class="code">% scons install declare</p>

<p>
As you might have guessed, we could have just skipped the first
<code>scons</code> invocation and gone straight to
<code>scons install declare</code>.  
</p>

<p>
By default, the package will get installed into our
<code>$LSST_DEVEL</code> area (or if we don't have
one, <code>$LSST_HOME</code>).  We can change this
destination passing <code>prefix=</code><em>dir</em>
as an argument to the <code>scons</code> command.
</p>

<a name="newpkg">
<h3>7.3  Creating a New LSST Package</h3></a>

<i>editing in progress</i>

<a name="release">
<h3>7.4  Creating a Package Release</h3></a>

<i>editing in progress</i>

<a name="resources">
<h2>8.  Additional Resources</h2></a>

If you have questions about getting started with development, feel
free to contact Ray Plante (rplante at ncsa.uiuc.edu).  However, if
you are planning to do development and were fairly successful in
getting the software installed and code checked out of SVN, then you
should start to become familiar with our issue and bug tracking
system, Trac.  

<a name="trac">
<h3>8.1  Issue Tracking with Trac</h3></a>

<p>
Our issue tracking system is a web-based product called
<a href="http://www.trac.org">Trac</a> which can be access via
<a href="http://dev.lsstcorp.org/trac">http://dev.lsstcorp.org/trac</a>.  
It includes two very useful features that help support collaborative
development:
</p>

<ul>
  <li> <strong>A subversion repository browser</strong>:  this allows
       one to not only easily browse the source code but also track
       the history of updates.  </li>
  <li> <strong>A Wiki</strong>:  this is an environment that allows
       us to easily create and edit web pages over the web using 
       simple text mark-up (simpler than HTML) in a collaborative
       way.  We can use this to capture highly dynamic information
       like programming tips and "how-tos".  
</ul>

In order to edit on the Wiki and to submit bug reports, you will need
to get a login for the Trac portal; consult <a href="#traclogin">these
instructions</a> for more information.  

<i>editing in progress</i>

<a name="continuum">
<h3>8.2  Build Testing with BuildBot</h3></a>

<p>
The software stack is automatically built and tested using the
BuildBot system on dev.lsstcorp.org.  To see the current status, see
the <a href="http://dev.lsstcorp.org/build">BuildBot summary
page</a>. 
</p>

<i>editing in progress</i>

</body> </html>
